@{
    Layout = null;
}

<!DOCTYPE html>

<html style="overflow: hidden">
<head>
    <meta name="viewport" content="width=device-width" />
    <title></title>
</head>
<body unselectable="on" class="unselectable" style="margin:0">
    <canvas id="glscreen"></canvas>
    <script src="../../Scripts/jquery-2.1.4.min.js"></script>
    <script src="../../Scripts/jquery.signalR-2.2.0.min.js"></script>
    <script src="../../Scripts/Fractals/gdo.apps.Fractals.webgl.js"></script>
    <script src="../../Scripts/Fractals/gdo.apps.Fractals.params.js"></script>
    <script>
        $(function () {          
            $(document).ready(function () {
                params = new params(0.0, 0.0, 0.0, 0.0, 0.0, -2.0, 100, -3.0, 0.5, 0.0);
                var gdo = parent.gdo;
                gdo.net.app["Fractals"].initClient(params);
            });
        });
    </script>

    <script id="2d-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;

        void main() {
        gl_Position = vec4(a_position, 0, 1);
        }
    </script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">

        #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
        #else
        precision mediump float;
        #endif
        precision mediump int;

        uniform float width;
        uniform float height;
        uniform float xRot;
        uniform float yRot;
        uniform float focal;
        uniform vec3 translation;
        uniform float eyeHeight;

        uniform int maxSteps;
        uniform float minDetail;

        uniform float ambience;
    
        uniform int modFunction;

        // Cylinder function
        float primitiveCylinder(vec3 p, vec2 h) {
        vec2 d = abs(vec2(length(p.xz),p.y)) - h;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0));
        }

        // Sphere function
        float primitiveSphere(vec3 p, float r) {
        return length(p)-r;
        }

        // Torus function
        float sdTorus( vec3 p, vec2 t ) {
        vec2 q = vec2(length(p.xz)-t.x,p.y);
        return length(q)-t.y;
        }

        // Twist function
        float opTwist( vec3 p ) {
        float c = cos(20.0*p.y);
        float s = sin(20.0*p.y);
        mat2  m = mat2(c,-s,s,c);
        vec3  q = vec3(m*p.xz,p.y);
        return sdTorus(q, vec2(0.2, 0.4));
        }

        // Mod function
        vec3 modPoint(vec3 p, float gap) {
        return mod(p,gap)-vec3(gap/2.0);
        }

        float DE(vec3 pos) {
            //
    
            if (modFunction == 1) {
                pos = modPoint(pos, 3.0);
            }
            //float d = opTwist(p);
            // float d = primitiveSphere(p, 0.5);
            //return d;

            // Treat as sphere beyond 2.0
            if (length(pos) > 2.0) {
            return length(pos) - 1.9;
            }

            const int Iterations = 16;
            float Bailout = 2.0;
            float Power = 8.0;

            vec3 z = pos;
            float dr = 1.0;
            float r = 0.0;
            for (int i = 0; i < Iterations ; i++) {
            r = length(z);
            if (r>Bailout) break;

            // convert to polar coordinates
            float theta = acos(z.z/r);
            float phi = atan(z.y,z.x);
            dr =  pow( r, Power-1.0)*Power*dr + 1.0;

            // scale and rotate the point
            float zr = pow( r,Power);
            theta = theta*Power;
            phi = phi*Power;

            // convert back to cartesian coordinates
            z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
            z+=pos;
            }
            return 0.5*log(r)*r/dr;
        }

        float shadow(vec3 ro, vec3 rd, float dist, float detail) {
            // Shadow softness - lower is softer
            float softness = 128.0;
            // Shadow density - lower is denser
            float density = 0.0;

            float res = 1.0;
            float t = 0.0;
            for(int i = 0; i < 1/0; i++) {
            if (t > dist) break;
            float d = DE(ro + rd*t);
            if( d < detail ) {
            return density;
            }
            res = min( res, softness*d/t );
            t +=d;
            if (i >= maxSteps-1) return 0.0;
            }
            return density+(1.0-density)*res;
        }

        vec4 march(vec3 ro, vec3 rd) {

            // Sky color
            vec4 color = vec4(0.0,0.0,0.0,1.0);

            // p - point of current ray
            vec3 p = ro;

            // Lighting
            vec3 lightLoc = vec3(4.0, 2.0, -2.0);
            float lightIntensity = 50.0;
            vec3 lightDirection;
            vec3 normal = vec3(0.0);
            float ao = 1.0;
            float attenuation = 1.0;

            // Shading
            vec4 ambientColour = vec4(0.0, 0.0, 0.0, 1.0);
            vec4 diffuseColour = vec4(1.0, 1.0, 1.0, 1.0);
            vec4 specularColour = vec4(1.0, 1.0, 1.0, 1.0);

            // t - total distance ray travelled
            float t = 0.0;

            float detail = minDetail;

            for(int i = 0; i < 1/0; ++i)  {
            if (i >= maxSteps) break;

            // ray origin + ray direction * total distance
            p = ro + rd * t;

            // find min detail
            float minVisibleDetail = (t/focal) * (0.5/width);
            detail = minVisibleDetail > minDetail ? minVisibleDetail : minDetail;

            // distance estimators
            // Fractal
            float d1 = abs(DE(p));
            // Floor
            float d2 = abs(p.y + 2.0);
            float d = min(d1,d2);

            if(d < detail) {
            if (d1 < d2) {

            ambientColour = vec4(1.0, 0.0, 1.0, 1.0);
            diffuseColour = vec4(1.0, 0.0, 1.0, 1.0);

            attenuation = lightIntensity/(pow((distance(p,lightLoc)), 2.0));
            attenuation = clamp(attenuation, 0.0, 1.0);
            lightDirection = normalize(-p+lightLoc);

            float shadingDetail = detail/2.0;
            vec3 xDir = vec3(shadingDetail,0.0,0.0);
            vec3 yDir = vec3(0.0,shadingDetail,0.0);
            vec3 zDir = vec3(0.0,0.0,shadingDetail);
            normal = normalize(vec3(DE(p+xDir)-DE(p-xDir),
            DE(p+yDir)-DE(p-yDir),
            DE(p+zDir)-DE(p-zDir)));

            // Ambient Occlusion
            float aoFactor = 0.0;
            float delta = detail;
            float aoTotal = 0.0;
            for (int j = 1; j < 6; j++) {
            vec3 aoPos = p + normal * delta * float(j);
            float surfaceDist = distance(aoPos, p);
            float nearestDist = abs(DE(aoPos));
            float expDist = 1.0/pow(2.0, float(i));
            aoTotal += expDist * abs(surfaceDist - nearestDist);
            aoFactor += expDist * max(surfaceDist, abs(surfaceDist - nearestDist));
            }

            ao = 1.0 - (aoTotal / aoFactor);

            break;

            } else {

            // Floor colour
            if (mod(p.x, 1.0) < 0.5 ) {
            if (mod(p.z, 1.0) < 0.5 ) {
            diffuseColour = vec4(0.0,0.0,0.0,1.0);
            ambientColour = vec4(0.0,0.0,0.0,1.0);
            } else {
            diffuseColour = vec4(1.0);
            ambientColour = vec4(1.0);
            }
            } else {
            if (mod(p.z, 1.0) < 0.5 ) {
            diffuseColour = vec4(1.0);
            ambientColour = vec4(1.0);
            } else {
            diffuseColour = vec4(0.0,0.0,0.0,1.0);
            ambientColour = vec4(0.0,0.0,0.0,1.0);
            }
            }

            normal = vec3(0.0, 1.0, 0.0);
            lightDirection = normalize(-p+lightLoc);

            break;
            }
            }

            // increase total distance by ray distance
            t += d;
            }

            // Shadows
            float s = shadow(p+2.0*detail*normal, lightDirection, distance(p, lightLoc), detail);

            // Shading
            // Ambience
            ambientColour.xyz *= ambience;
            color =   vec4(ambientColour.xyz + s * diffuseColour.xyz  * attenuation * max(dot(normal, lightDirection), 0.0)
            + s * specularColour.xyz * attenuation * pow(max(dot(normalize(reflect(lightDirection, normal)), rd), 0.0), 200.0)/3.0,1.0);

            // Ambient occlusion
            color.xyz *= ao;

            // Fog
            vec4 fogColor = vec4(0.0, 0.0, 0.0, 1.0);
            color = mix(color, fogColor, 1.0 - exp(-t*0.1));

            return color;

        }

        vec3 calcRayOrigin(float x, float y) {
            // y rotation
            float y2 = y*cos(yRot) - focal*sin(yRot);
            float focal2 = y*sin(yRot) + focal*cos(yRot);
            y = y2;

            // x rotation
            float x2 = x*cos(xRot) - focal2*sin(xRot);
            focal2 = x*sin(xRot) + focal2*cos(xRot);
            x = x2;

            // ro - ray origin
            // calculate where ray passes through the screen
            vec3 ro = vec3(x,y-eyeHeight, focal2);

            return ro;
        }

        void rayMarch() {

            // Keep eye in the origin of the scene
            vec3 eye = vec3(0, 0, 0);

            // Get x between -1.0 - 1.0
            float x = gl_FragCoord.x * 2.0 / width - 1.0;

            // Get y between -1.0 - 1.0
            float y = gl_FragCoord.y * 2.0 / height - 1.0;

            // Apply aspect ratio
            float ratio = height/width;
            y *= ratio;

            float xDiffAA = 0.5/width;
            float yDiffAA = 0.5*ratio/height;

            // Ray origin
            vec3 ro = calcRayOrigin(x, y);

            // Set pixel colour
            vec4 color = march(translation, normalize(ro));
            gl_FragColor = color;

            // Anti alias
            /*
            vec3 ro1 = calcRayOrigin(x+xDiffAA, y);
            vec3 ro2 = calcRayOrigin(x-xDiffAA, y);
            vec3 ro3 = calcRayOrigin(x, y+yDiffAA);
            vec3 ro4 = calcRayOrigin(x+xDiffAA, y-yDiffAA);
            vec4 c1 = march(translation, normalize(ro1));
            vec4 c2 = march(translation, normalize(ro2));
            vec4 c3 = march(translation, normalize(ro3));
            vec4 c4 = march(translation, normalize(ro4));
            gl_FragColor = (c1+c2+c3+c4)/4.0;
            */
        }

        void main() {
        rayMarch();
        }

    </script>

</body>
</html>
