<!--
/**
 * Created by dm214 MSc Computing Science Sep2015.
 * Realtime geoip visualization of transactions
 * as they are first relayed by full-nodes into the P2P network
-->
<!DOCTYPE html>
<html>
<head lang="en">
<style type="text/css">
  #globecontainer {
	max-width: 3840px;
	height: 3840px;
	margin: 0;
  }

  #textarea {
	  color: #ffffff;
	  font-family: verdana, sans-serif;
  }

</style>
</head>
<body bgcolor="#000000">
<div id="globecontainer"></div>
<div id="textarea">
	NumNodes: <div id="numNodes" style="display:inline-block;"></div><br>
	BlockHeight: <div id="blkHeight" style="display:inline-block;"></div><br>
	At Time: <div id="time" style="display:inline-block;"></div><br>
	NumTxs: <div id="numTxs" style="display:inline-block;"></div><br>
</div>
</body>


<script src="../../Scripts/Bitcoin/globe/third-party/three.min.js"></script>
<script src="../../Scripts/Bitcoin/globe/globe.js"></script>
<script>

	var container = document.getElementById('globecontainer');
	var globe = new DAT.Globe(container);
	var allIPv4Nodes={};
	var numTxs=0;

	function init() {

		initNodes();
		addTxs();
	}

	function initNodes(){

		var xmlhttp = new XMLHttpRequest();
		//var url = "http://cors.io/?u=https://getaddr.bitnodes.io/api/v1/snapshots/latest/";   //FIX added to prevent error  "No 'Access-Control-Allow-Origin' header is present on the requested resource."
		var url = "https://bitnodes.21.co/api/v1/snapshots/latest";

		xmlhttp.onreadystatechange = function() {
			if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {

				var resObj = JSON.parse(xmlhttp.responseText);
				//console.log(resObj);
				var allNodeLocns = getNodeLocns(resObj.nodes);
				document.getElementById('numNodes').innerHTML = resObj.total_nodes;
				document.getElementById('blkHeight').innerHTML = resObj.latest_height;
				var timestamp = new Date(resObj.timestamp*1000);
				document.getElementById('time').innerHTML = timestamp.getHours()+':'+ timestamp.getMinutes()+':'+
															timestamp.getSeconds();

				globe.addData(allNodeLocns, {format: 'magnitude', name:'allNodeLocns', animated: false});
				globe.createPoints();
				globe.animate();
			}
		};

		xmlhttp.open("GET", url, true);
		xmlhttp.send();
	    console.log('Retrieved current backbone nodes');
	}

	function getNodeLocns(nodeArr){

		var nodeLocns=[];
		for (var k in nodeArr){
			var node = nodeArr[k];

			// create global object for ipv4 addresses only
			if (k.substring(0,1)!='[') {
				var addr = k.substring(0, k.indexOf(':'));
				var newnode={
					"proto_ver":node[0],
					"user_agent":node[1],
					"cnxn_since":node[2],
					"block_height":node[4],
					"hostname":node[5],
					"city":node[6],
					"country":node[7],
					"lat":node[8],
					"long":node[9],
					"timezone":node[10],
					"asn":node[11],
					"org":node[12],
					"mag":0
				};
				allIPv4Nodes[addr]=newnode;
			}

			//create array to display all nodes
			nodeLocns.push(node[8]);
			nodeLocns.push(node[9]);
			nodeLocns.push(0.00);
		}
		console.log(allIPv4Nodes);
		return nodeLocns;
	}

	function addTxs(globe){
		var ws="wss://ws.blockchain.info/inv";
		bcWebsocket = new WebSocket(ws);
		bcWebsocket.onopen = function(openEvent) { onOpen(openEvent) };
		bcWebsocket.onmessage = function(msgEvent) { onMessage(msgEvent) };
	}

	function onOpen(openEvent) {
		console.log("connecting");
		//subscribe to realtime transaction notifications
		transmit({"op":"unconfirmed_sub"});
		console.log("subscribed to unconfirmed transactions");
		//subscribe to realtime block notifications
		transmit({"op":"blocks_sub"});
		console.log("subscribed to new block notifications");
	}

	function transmit(payload) {
		bcWebsocket.send(JSON.stringify(payload));
	}

	function onMessage(msgEvent) {

		var msg = JSON.parse(msgEvent.data);

		if (msg.op=='utx') {
			var pointData=[]
			var tx_addr = msg.x.relayed_by;
			console.log('new tx relayed by: ' + tx_addr);
			if (tx_addr != undefined && tx_addr != '127.0.0.1'  &&
				tx_addr !='0.0.0.0' && tx_addr.substring(0,1)!='['){

				console.log('--in '+allIPv4Nodes[msg.x.relayed_by].city+','+allIPv4Nodes[msg.x.relayed_by].country);

				pointData.push(allIPv4Nodes[msg.x.relayed_by].lat)
				pointData.push(allIPv4Nodes[msg.x.relayed_by].long)
				pointData.push((++allIPv4Nodes[msg.x.relayed_by].mag) / 10);

				globe.addData(pointData, {format: 'magnitude', name:'allNodeLocns', animated: false});
				globe.createPoints();
				//globe.animate();

				document.getElementById('numTxs').innerHTML = ++numTxs;
			}
		}
	}

	window.addEventListener("load", init, false);

</script>
</html>
